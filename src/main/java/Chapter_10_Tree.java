/**
 * Created on 2023-04-05
 * Project 2023JavaStudy
 */
public class Chapter_10_Tree {
    /**
     *          트리
     * 트리는 데이터 사이의 계층 관계를 나타내는 자료구조이다.
     *
     *
     *                                    Root -----------------------------Lv 0
     *                        1           leaf           2 -----------------Lv 1
     *                   3       leaf       --------------------------------Lv 2
     *            leaf leaf leaf            --------------------------------Lv 3
     *
     *
     *  - 루트 : 트리의 가장 윗부분을 루트라고 한다. 하나의 루트에는 하나의 루트가 있다.
     *  - 리프 : 트리의 가장 아랫부분에 위치하는 노드를 리프(leaf)라고 한다. 이때 '가장 아래에 위치한다.'는 말은 물리적으로 맨 아래가 아닌 더 이상
     *         가지가 뻗어나가지 않는다는 의미이다.
     *  - 안쪽 노드 : 루트를 포함하여 리프를 제외한 노드를 안쪽 노드라고 한다.
     *  - 자식 : 어떤 노드로부터 가지로 연결된 아래쪽 노드를 자식이라고 한다. 자식을 여러 개 가질 수 있다.
     *  - 부모 : 어떤 노드에서 위로 연결된 노드를 부모라고 한다. 노드는 1개의 부모를 가진다. 루트만은 예외이다.
     *  - 형제 : 같은 부모를 가지는 노드를 형제라고 한다.
     *  - 조상 : 어떤 노드에서 가지로 연결된 위쪽 노드 모두를 조상이라고 한다.
     *  - 자손 :  어떤 노드에서 가지로 연결된 아래쪽 노드 자손을 모두 자손이라고 한다.
     *  - 레벨 : 루트로부터 얼마나 떨어져 있는가를 레벨이라고 한다. 루트 (레벨 0) 부터 아래로 갈수록 레벨이 1씩 올라간다.
     *  - 차수 : 노드가 갖는 자식의 수를 차수(degree)라고 한다.
     *  - 높이 : 루트로부터 가장 멀리 떨어진 리프까지의 (최대 레벨)을 높이라고 한다.
     *  - 서브 트리 : 트리 안에서 다시 어떤 노드를 루트로 정하고 그 자손으로 이뤄진 트리를 서브트리라고 한다.
     *  - 널 트리 : 노드, 가지가 없는 트리를 널 트리(null tree) 라고 한다.
     *  - 순서 트리와 무순서 트리 : 형제 노드의 순서가 있는지 없는지에 따라 트리를 두 종류로 분류한다. 형제 노드의 순서를 따지면 순서트리(orderedTree), 따지지 않으면 무순서트리(unorderedTree)라고 한다.
     *
     *
     *
     *     (예제 트리)
     *
     *                               A
     *                    B                      C
     *             D           E             F       G
     *          H           I     J       K     L
     *
     *
     *          너비 우선 탐색(breadth-first Search)
     * 너비우선 탐색은 낮은레벨에서 시작해서 왼쪽 -> 오른쪽 방향으로 한 레벨의 검색이 끝나면 다음 레벨로 내려가는 탐색 방법을 의미한다.
     *
     *          순서 : A -> B -> C -> D -> E -> F -> G -> H -> I -> J -> K -> L
     *
     *          깊이 우선 탐색 (depth-first Search)
     * 깊이 우선 탐색은 리프까지 내려가면서 검색하는 것을 우선순위로 하는 탐색 방법이다. 리프에 도달해서 더 이상 검색을 진행할 곳이 없으면
     * 부모로 돌아간다.
     *
     *          순서  A -> B -> D -> H -> I -> E -> J -> C -> F -> K -> L -> G (예시)
     *
     *           깊이 우선 탐색에서 순회 방식
     *
     *  1. 전위 순회 (Preorder)
     *      노드 -> 왼쪽 자식 -> 오른쪽 자식 순으로 순회하는 방법이다. 위 예시 트리를 전위 순회하면 * A -> B -> D -> H -> I -> E -> J -> C -> F -> K -> L -> G가 된다.
     *
     *  2. 중위 순회 (Inorder)
     *      왼쪽자식 -> 노드 -> 오른쪽 자식 순으로 순회하는 방식이다. 위 예시 트리를 중위 순회 하면 * H -> D -> B -> I -> E -> J -> A -> K -> F -> L -> C -> G가 된다.
     *
     *  3. 후휘 순회(Postorder)
     *      왼쪽자식 -> 오른쪽 자식 -> 노드 순으로 순회하는 방식이다. 위 예시 트리를 후휘 순회 하면 * H -> D -> I -> J -> E -> B -> K -> L -> F -> G ->C -> A가 된다.
     *
     *
     *
     *
     *
     *              이진트리와 이진검색
     *   노드가 왼쪽 자식과 오른쪽 자식을 갖는 트리를 이진 트리(binary Tree)라고 한다. 이때 각 노드의 자식은 2명 이하로 유지해야 한다.
     *   또한 이전 트리의 특징은 왼쪽자식, 오른쪽 자식을 구분한다는 것이다.
     *
     *              완전 이진 트리
     *   루트부터 노드가 채워져 있으면서 같은 레벨에서는 왼쪽에서 오른쪽으로 노드가 채워져 있는 이진트리를 완전 이진 트리(complete binary tree)라고 한다.
     *
     *          1. 마지막 레벨을 제외한 레벨은 노드를 가득 채운다.
     *          2. 마지막 레벨은 왼쪽부터 오른쪽 방향으로 노드를 채우되 반드시 끝까지 채울 필요는 없다.
     *
     *
     *            예시)
     *                           0
     *                   1             2
     *              3       4       5      6
     *           7    8   9  10  11
     *
     *    높이가 k 인 완전 이진트리가 가질 수 있는 노드의 최대 개수는 2^(k+1) - 1 개이다. 위 예시는 높이가 3이므로 노드 최대 개수는 15이다.
     *
     *
     *
     *              이진 검색 트리
     *    이진 검색 트리( binary search tree )는 이진 트리가 아래의 조건을 만족하면 된다.
     *
     *    1. 어떤 노드 N을 기준으로 왼쪽 서브 트리 노드의 모든 키 값은 노드 N의 키 값보다 작아야 한다.
     *    2. 오른쪽 서브 트리 노드의 키 값은 노드 N의 키 값보다 커야 한다.
     *    3. 같은 키 값을 갖는 노드는 존재하지 않는다.
     */
}
