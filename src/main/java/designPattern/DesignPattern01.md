# 디자인 패턴

|생성 패턴|구조 패턴|행위 패턴|
|:-------:|:-------:|:------:|
|Singleton|Adapter|Command|
|Abstract Factory| Composite| Interpreter|
|Factory Method| Decorator| Iterator|
|Builder|Facade|Mediator|
|Prototype|Flyweight|Memento|
|   |Proxy|Observer|
|   |   |State|
|   |   |Strategy|
|   |   |Template Method|


<hr/>

## 생성

### 1.Singleton
1. 하나의 인스턴스만을 만들었다는 것을 보장하기 위해서 사용한다.
2. 생성자는 private으로 지정
3. static 필드에 본인을 선언해 놓는다.
4. new 키워드 대신 본인 인스턴스를 얻는 메소드가 있다. (일종의 FactoryMethod)

### 2.Factory Method
1. 인스턴스를 생성하는 공장을 구현한 것이다.
2. 인스턴스 생성 방법을 상위에서 구현하되, 구체적 클래스 이름까지 정하지는 않는다.
3. `if - else` 혹은 `swtich - case` 등으로 여러 제품을 만드는 공장에서 분기 처리를 할 수 있다.
4. 내부에서 Template Method 패턴으로 구성된다.

### 3.Abstract Factory
1. 추상적인 부품을 만든다.
2. 만들어 놓은 추상적인 부품으로 추상적인 결과물을 만든다.
3. 구현에는 주목하지 않고 인터페이스 구축에 주목한다. 
4. abstract 부품을 추가하면 abstractFactory에서 이를 만드는 과정을 추가하는 일이 필요하다.

### 4. Builder
1. 팩토리, 추상 팩토리에 의존하여 만들 수 있는 인스턴스의 개수가 많을 때 변경을 고려할 만하다.
2. 선택 사항을 메소드로 제공하며, 각 메소드의 리턴값은 빌더 본인이 된다.
3. 2번의 이유로 메소드 체이닝을 할 수 있게 된다.

### 5. Prototype
1. 일정 대상을 놓고 복사하여 사용하는 패턴이다.
2. 원본을 생성할 때 많은 비용, 시간이 드는 경우 사용한다.
3. cloneable을 구현하여 clone을 한다.
4. 지금까지 예제에서는 얇은 복사라는 한계점이 보인다.


<hr/>

## 구조

### 1. Adapter
1. 필요한 형태로 변환해서 이용하는 경우, (제공된 것, 필요한 것) 사이의 갭을 메워준다.
2. 필드에 구현하건, 상속 받건 하는 방법으로 구현된다.
3. 변압기를 생각하면 이해하기 쉽다.

### 2. Composite
1. 객체들의 관계를 트리로 구성하여 부분, 전체 계층을 표현하는 패턴
2. 단일 객체, 복합 객체를 모두 동일하게 다룰 수 있게 한다.
3. 다형성을 이용한다.

### 3. Decorator
1. 클래스 수정 없이 새로운 기능을 붙일수 있다.
2. 객체의 결합을 통해 기능을 유연하게 확장할 수 있다.

### 4. Facade
1. 하나의 통로로 받고 일을 할당한다.
2. 의존 관계나 실행 흐름을 안으로 숨긴다.

### 5. FlyWeight
1. 무거운 대상을 사용할 때 쓸데 없이 인스턴스 만들기를 남발하지 않는다.
2. 최대한 공유하여 사용한다.
3. 추가적으로 Pool에 캐싱해서 반복 사용할 경우, 인메모리를 최대한 활용한다.

### 6. Proxy
1. 대리인자를 두고 필요할 때 initialize 한다.
2. 대리인이 처리할 수 있는 부분은 최대한 처리한다.
3. Proxy는 본체를 안다.

<hr>

### 1. Command
1. '명령'을 표현하는 클래스를 만들어서 이력을 남긴다.
2. '명령'을 객체로 만든다. (메소드가 아니라)
3. '명령' 단위로 인스턴스를 만들어서, 문제가 되지 않을까 싶다.

### 2. Interpreter
1. 만약 특정 문제만을 해결하는 '미니 언어'(DSL)를 만든다고 했을 때 이를 파싱해서 일반 언어로 실행할 수 있도록 통역하는 역할을 하는 것
2. DSL을 만듦으로써 한 문제에 집중할 수 있으며, 특화 시킬 수 있다.
3. 정규 표현식 등이 예시이다.

### 3. Iterator
1. 내부적으로 어떻게 동작하는지 알 수 없더라도, 반복할 수 있도록 해준다.
2. 컨테이너와 알고리즘을 분리시킨다.
3. 자바에서는 Iterator, Iterable을 활용한다. 

### 4. Mediator
1. 다양한 객체 간의 상호작용을 한 곳으로 모은다.( 상호 작용 ↑ == 결합도의 증가 ↑ )
2. 상호작용을 하는 객체끼리는 알 필요가 없고, 중재자만 알면 된다. 
3. 복잡한 관계를 단순화 한다.

### 5. Memento
1. 객체의 상태 값을 캡쳐한다. 
2. 스냅샷을 통해 언제든 돌아갈 수 있다.
3. originator, Memento, CareTaker 세 부분으로 구성된다.
4. originator : 대상, Memento: 스냅샷, CareTaker: 캡쳐, 롤백 행위를 하는 객체
5. 캡슐화를 파괴하지 않아도 된다. 

### 6. Observer
1. 관찰자를 둬서 관찰 대상의 상태가 변경되면 관찰자로 알린다.
2. 일종의 Publish - Subscribe와 유사하다. ( 둘의 차이는 MessageBroker, EventBus 존재 유무 )
3. Observer는 Observer, Subsrcriber가 서로 알지만 pub-sub은 메시지 브로커가 둘 사이에 끼어 있기 떄문에서 꼭 서로 알 필요는 없다.

### 7. State
1. 상태를 클래스로 표현한다.
2. 내부 상태(클래스)가 변경되면 행동을 변경하게 할 수 있다. 

### 8. Strategy
1. 문제를 해결하고자 하는 방법을 분리한다.
2. 이 '방법'을 갈아끼울 수 있도록 구성한다.
3. Java에서 MethodReference나 Lambda를 파라미터로 받는 메소드들이 이런 경우이다.

### 9. Template Method
1. 상위 템플릿이 될 메소드가 정의되어 있고 그 안에 사용될 메소드의 틀만 제공된다.
2. 특정 틀 안에서 메소드만 재정의해서 실행시키는 방식이다.
3. 뼈대를 미리 구성해뒀기 때문에 큰 흐름은 상위 클래스에서 지정한다.
