# 디자인 패턴

|생성 패턴|구조 패턴|행위 패턴|
|:-------:|:-------:|:------:|
|Singleton|Adapter|Command|
|Abstract Factory| Composite| Interpreter|
|Factory Method| Decorator| Iterator|
|Builder|Facade|Mediator|
|Prototype|Flyweight|Memento|
|   |Proxy|Observer|
|   |   |State|
|   |   |Strategy|
|   |   |Template Method|


<hr/>

## 생성

### 1.Singleton
1. 하나의 인스턴스만을 만들었다는 것을 보장하기 위해서 사용한다.
2. 생성자는 private으로 지정
3. static 필드에 본인을 선언해 놓는다.
4. new 키워드 대신 본인 인스턴스를 얻는 메소드가 있다. (일종의 FactoryMethod)

### 2.Factory Method
1. 인스턴스를 생성하는 공장을 구현한 것이다.
2. 인스턴스 생성 방법을 상위에서 구현하되, 구체적 클래스 이름까지 정하지는 않는다.
3. `if - else` 혹은 `swtich - case` 등으로 여러 제품을 만드는 공장에서 분기 처리를 할 수 있다.
4. 내부에서 Template Method 패턴으로 구성된다.

### 3.Abstract Factory
1. 추상적인 부품을 만든다.
2. 만들어 놓은 추상적인 부품으로 추상적인 결과물을 만든다.
3. 구현에는 주목하지 않고 인터페이스 구축에 주목한다. 
4. abstract 부품을 추가하면 abstractFactory에서 이를 만드는 과정을 추가하는 일이 필요하다.

### 4. Builder
1. 팩토리, 추상 팩토리에 의존하여 만들 수 있는 인스턴스의 개수가 많을 때 변경을 고려할 만하다.
2. 선택 사항을 메소드로 제공하며, 각 메소드의 리턴값은 빌더 본인이 된다.
3. 2번의 이유로 메소드 체이닝을 할 수 있게 된다.

### 5. Prototype
1. 일정 대상을 놓고 복사하여 사용하는 패턴이다.
2. 원본을 생성할 때 많은 비용, 시간이 드는 경우 사용한다.
3. cloneable을 구현하여 clone을 한다.
4. 지금까지 예제에서는 얇은 복사라는 한계점이 보인다.


<hr/>

## 구조

### 1. Adapter
1. 필요한 형태로 변환해서 이용하는 경우, (제공된 것, 필요한 것) 사이의 갭을 메워준다.
2. 필드에 구현하건, 상속 받건 하는 방법으로 구현된다.
3. 변압기를 생각하면 이해하기 쉽다.

### 2. Composite
1. 객체들의 관계를 트리로 구성하여 부분, 전체 계층을 표현하는 패턴
2. 단일 객체, 복합 객체를 모두 동일하게 다룰 수 있게 한다.
3. 다형성을 이용한다.

### 3. Decorator
1. 클래스 수정 없이 새로운 기능을 붙일수 있다.
2. 객체의 결합을 통해 기능을 유연하게 확장할 수 있다.

### 4. Facade
1. 하나의 통로로 받고 일을 할당한다.
2. 의존 관계나 실행 흐름을 안으로 숨긴다.

### 5. FlyWeight
1. 무거운 대상을 사용할 때 쓸데 없이 인스턴스 만들기를 남발하지 않는다.
2. 최대한 공유하여 사용한다.
3. 추가적으로 Pool에 캐싱해서 반복 사용할 경우, 인메모리를 최대한 활용한다.

### 6. Proxy
1. 대리인자를 두고 필요할 때 initialize 한다.
2. 대리인이 처리할 수 있는 부분은 최대한 처리한다.
3. Proxy는 본체를 안다.
