import org.junit.jupiter.api.Test;

public class Chapter_03_Search {
    /**
     *  1.  배열 검색
     *
     *  1-1. 선형 검색 : 무작위로 늘어놓은 데이터 모임에서 검색을 수행한다.
     *  1-2. 이진 검색 : 일정한 규칙으로 늘어놓은 데이터 모임에서 아주 빠른 검색을 수행한다.
     *  1-3. 해시법 : 추가, 삭제가 자주 일어나는 데이터 모임에서 아주 빠른 검색을 수행한다.
     *    1-3-1. 체인점 : 같은 해시 값의 데이터를 선형 리스트로 연결하는 방법
     *    1-3-2. 오픈 주소법 : 데이터를 위한 해시 값이 충돌할 때 재해시하는 방법
     *
     *
     *  데이터 집합이 있을 때 검색에 사용할 알고리즘은 계산 시간이 짧은 것을 선택하면 된다. 그러나 데이터 집합에 대한 검색뿐 아니라 데이터의 추가,
     *  삭제 등을 자주하는 경우라면 검색 이외의 작업에 소요되는 비용을 종합적으로 평가하여 알고리즘을 선택해야 한다.
     *  예를 들어 데이터 추가를 자주 하는 경우에는 검색이 빠르더라도 데이터의 추가 비용이 많이 들어가는 알고리즘은 피하는 것이 좋다.
     *
     *
     *
     *
     *      1-1. 선형 검색
     *
     * 요소가 직선 모양으로 늘어선 배열에서의 검색은 원하는 키 값을 갖는 요소를 만날 때까지 맨 앞부터 순서대로 요소로를 검색하면 되는데, 이를 선형 검색(linear search)
     * 또는 순차 검색(sequential search) 이라는 알고리즘이다.
     *
     * 이 경우의 탐색은 조건을 두 가지 갖다.
     *
     *      조건 1) 검색할 값을 발견하지 못하고 배열의 끝을 지나간 경우
     *      조건 2) 검색할 값과 같은 요소를 발견한 경우
     *
     */

    @Test
    void seqSearch(){
        int key = 55;
        int i = 0;
        int[] target = {22,8,55,32,120,55,70};
        int idx = 0;


//        while (true) {
//            if( i >= target.length - 1 ) {
//                idx = -1;
//                break;
//            }
//            if(target[i] == key) {
//                idx = i;
//                break;
//            }
//            i++;
//        }
        for ( ; i < target.length; i++){
            if(target[i] == key){
                break;
            } else if (target[i] != key && i == target.length -1){
                i = -1;
                break;
            }
        }

        idx = i;

        System.out.println(idx);
    }
    /**
     * SeqSearch는 배열의 처음부터 끝까지 순회하며 지정된 key와 같은 요소를 검색하면 인덱스를 반환한다. 만약 key와 같은 요소가 여러 개라면
     * 처음으로 발견한 이후 종료된다.
     *
     *
     *      1-2. 보초법
     *
     * 선형 검색은 반복할 때마다 종료조건 - 1) 검색할 값을 발생하지 못하고 배열의 끝을 지나간 경우, 2) 검색할 값과 같은 요소를 발견할 경우-을 체크한다.
     * 이 비용은 무시하기 어렵다. 이 비용을 반으로 줄이는 보초법(sentinel method)이다.
     */

}
